#include "coro_states.h"

#include <elfutils/libdw.h>
#include <elfutils/libdwfl.h>
#include <gelf.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "libcorostacks.h"
#include "libcorostacks_int.h"
#include "utils.h"

/* supported methods to load state table */
typedef enum
{
    ST_SOURCE_FILE, /* from separate file, generated by modified libcoro */
    ST_SOURCE_COREDUMP /* directly from address space in the core file */
}
st_source_t;

struct file_impl
{
    FILE* input;
};

struct coredump_impl
{
    csAddr_t table_addr;
    size_t cur_idx;
    Elf *elf;
};

union impl
{
    struct file_impl file;
    struct coredump_impl coredump;
};

struct state_table
{
    st_source_t source_type;
    union impl impl;
};

st_result_t
st_open_from_file(state_table_t *handle, const char *filepath)
{
    struct state_table *st = (struct state_table*) handle;
    st->source_type = ST_SOURCE_FILE;

    st->impl.file.input = fopen(filepath, "rb");
    if (!st->impl.file.input)
        goto file_open_fail;

    return ST_SUCCESS;

file_open_fail:
    error_report(CS_IO_ERROR, "Failed to open file \"%s\": %s",
                 filepath, strerror(errno));
    return ST_ERROR;
}

typedef struct find_symbol_arg
{
    const char *sym_name;
    GElf_Sym *sym;
    bool found;
}
find_symbol_arg_t;

static int
find_symbol_cb(Dwfl_Module *mod, void **userdata, const char *name,
                          Dwarf_Addr start, void *arg_void_p)
{
    find_symbol_arg_t *arg = (find_symbol_arg_t *) arg_void_p;

    int n_symbols = dwfl_module_getsymtab(mod);

    for (int i = 0; i < n_symbols; ++i)
    {
        if (strcmp(dwfl_module_getsym(mod, i, arg->sym, NULL), arg->sym_name) == 0)
        {
            arg->found = true;
            return DWARF_CB_ABORT;
        }
    }
    return DWARF_CB_OK;
}

static int
find_symbol(Dwfl *dwfl, const char *name, GElf_Sym *found_sym)
{
    find_symbol_arg_t arg = {
        .sym_name = name,
        .sym = found_sym,
        .found = false
    };

    dwfl_getmodules(dwfl, find_symbol_cb, &arg, 0);

    if (arg.found)
        return ST_SUCCESS;

    return ST_ERROR;
}

st_result_t
st_open_from_coredump(state_table_t *handle, Dwfl *dwfl, Elf *coredump_elf)
{
    struct state_table *st = (struct state_table*) handle;
    st->source_type = ST_SOURCE_COREDUMP;
    st->impl.coredump.cur_idx = 0;
    st->impl.coredump.elf = coredump_elf;

    GElf_Sym sym;
    if (find_symbol(dwfl, "__coro_state_table", &sym) != ST_SUCCESS)
        goto find_symbol_fail;

    int ret = coredump_vmem_read(coredump_elf, sym.st_value, sizeof(csAddr_t),
                           (char *) &st->impl.coredump.table_addr);
    if (ret != CS_OK)
        return ST_ERROR;

    return ST_SUCCESS;

find_symbol_fail:
    error_report(CS_INTERNAL_ERROR,
                 "__coro_state_table symbol was not found in coredump");
    return ST_ERROR;
}

void
st_close(state_table_t *handle)
{
    struct state_table *st = (struct state_table*) handle;
    if (st->source_type == ST_SOURCE_FILE)
    {
        fclose(st->impl.file.input);
    }
}

int
st_next_entry(state_table_t *handle, ste_t *entry)
{
    struct state_table *st = (struct state_table *) handle;

    if (st->source_type == ST_SOURCE_FILE)
    {
        struct file_impl *impl = &st->impl.file;

        if (fread(entry, sizeof(ste_t), 1, impl->input) != 1)
            return ST_EOF;

        if (entry->sp == 0)
        {
            return ST_EOF;
        }

        return ST_ENTRY_PRESENT;
    }
    
    else if (st->source_type == ST_SOURCE_COREDUMP)
    {
        struct coredump_impl *impl = &st->impl.coredump;

        csAddr_t entry_addr = impl->table_addr + impl->cur_idx * sizeof(ste_t);
        int ret = coredump_vmem_read(impl->elf, entry_addr, sizeof(ste_t),
                           (char *) entry);
        if (ret != CS_OK)
            return ST_ERROR;

        if (entry->sp == 0)
            return ST_EOF;

        impl->cur_idx++;

        return ST_ENTRY_PRESENT;
    }

    cs_unreachable();
}

void
st_reset_cursor(state_table_t *handle)
{
    struct state_table *st = (struct state_table *) handle;

    if (st->source_type == ST_SOURCE_FILE)
    {
        fseek(st->impl.file.input, 0, SEEK_SET);
    }
    else if (st->source_type == ST_SOURCE_COREDUMP)
    {
        struct coredump_impl *impl = &st->impl.coredump;
        impl->cur_idx = 0;
    }

    cs_unreachable();
}

int
st_get_by_tid(state_table_t *handle, pid_t tid, ste_t *entry)
{
    struct state_table *st = (struct state_table *) handle;

    if (st->source_type == ST_SOURCE_FILE)
    {
        st_reset_cursor(handle);
        
        while (fread(entry, sizeof(ste_t), 1, st->impl.file.input) == 1)
        {
            if (entry->tid == tid)
                return ST_ENTRY_PRESENT;
        }

        return ST_EOF;
    }
    else if (st->source_type == ST_SOURCE_COREDUMP)
    {
        NOT_IMPLEMENTED;
    }

    cs_unreachable();
}
